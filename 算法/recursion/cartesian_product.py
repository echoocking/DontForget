from copy import deepcopy

"""

递归可以用来解决一些for循环很难处理的问题，所以想要试试
写了一个递归，从设计到最后的实现，每一步都是自己扣出来的，比看其他人的递归要难很多。
花的时间也多很多，大概用了两个小时。其实想想也还好，做下去的话，细心和耐心的做下去，总会有所收获的。
一开始的时候，认为需要两个参数，但是实际写的时候发现，其中一个参数完全可以用另外一个参数去生成，并且两个参数的话，后续也不好调整
这个速度如果在笔试的时候，估计是要挂的 hhh

关于解算法题的一点思考
1.先需要梳理问题，也就是算法的步骤。拿本题来说，列表 A = [[..], [..], [..] ... ,[..], [..]], 需要递归到下标n-1 与 下标n进行合并。合并的结果再与n-2进行合并...依次类推，最终完成整个列表的合并
没有思路的时候，可以画图分析分析，然后用自然语言描述算法，会降低初始难度。
2.当算法较为清晰时，可以开始编写代码了。编写代码的过程中，也会对算法进行一些修正。如果跑起来有问题，建议先直接看代码，再次过一遍思路，而不是直接尝试修改代码。想明白了，再去实现。
3.及时的用实际的数据去检验代码的正确性。
4.用一些异常数据进行校验

"""


def self_cartesian(l2):
    """

    :param l2: [[1,2], [1,3]]
    :return: [[], []]
    """
    if len(l2) == 1:
        l1 = l2[0]
        return [[i] for i in l1]

    else:
        l1 = l2[0]
        tem_l2 = l2[1:]
        tem_l2 = [i for i in tem_l2]
        cart_res = self_cartesian(tem_l2)
        contact_res = []
        for item_1 in l1:
            for item_2 in cart_res:
                # 在循环的时候，列表的地址是一直被引用的，想要不相互影响得新生成从一个列表。
                tem_item_2 = deepcopy(item_2)
                tem_item_2.append(item_1)
                contact_res.append(tem_item_2)
        return contact_res


if __name__ == '__main__':
    res = self_cartesian([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
    print(res)


